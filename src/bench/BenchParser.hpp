//
// Written by Carolina P. Nogueira 2016
// Refactored by Deutschmann 28.09.2021
//

#pragma once

#include "skip_parser.hpp"
#include "bench_grammar.hpp"
#include <fstream>

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/functional/hash.hpp>
#include <boost/unordered_map.hpp>
#include <unordered_map>
#include <stdexcept>

#include "BenchmarkLib.h"


#define OUTPUT_GATE_T    "OUTPUT"
#define INPUT_GATE_T     "INPUT"
#define FLIP_FLOP_GATE_T "DFF"
#define BUFFER_GATE_T    "BUFF"
#define NOT_GATE_T       "NOT"
#define AND_GATE_T       "AND"
#define OR_GATE_T        "OR"
#define NAND_GATE_T      "NAND"
#define NOR_GATE_T       "NOR"
#define XOR_GATE_T       "XOR"

/* Type definitions */
typedef std::string label_t;                        ///< Type definition for labels
typedef bench_format::bench_node_type bench_node_t; ///< Type definition for a node of the ISCAS85/89/99 bench format
typedef size_t unique_ID_t;             ///< Type definition for unique identifiers for circuits
typedef std::set<size_t> set_of_circuit_t;     ///< Type definition for set of circuits

/**
 * \struct circuit_node_type
 * \brief Struct that represents a node from a circuit. 
 *
 */
typedef struct circuit_node_t {
    size_t id;                  ///< Unique ID for a node
    std::string label;               ///< Node Label
    std::string gate_type;           ///< Type of the gate (ex. AND, NOT, OR)
    std::set<size_t> input_id_list;  ///< set containing all the inputs of the respective gate
    std::set<size_t> output_id_list; ///< set containing all the outputs of the respective gate
} circuit_node_t;

typedef std::list<circuit_node_t> list_of_circuit_t; ///< Type definition for list of circuits


/**
 * \class BenchParser
 * 
 * \brief Class to parse and convert bench nodes into circuits nodes.
 *
 *  Bench nodes are generated by parsing ISCAS85/89/99 bench format files.
 *
 * \authors {Carolina Nogueira, Lucas Deutschmann}
 * 
 */
class BenchParser {
private:

    size_t id_counter;

    std::set<label_t> output_labels;     ///< Set containing bench node labels of all OUTPUT gates
    std::set<label_t> ff_labels;   ///< Set containing bench node labels of all FLIP FLOP gates.
    ///<  When a FLIP FLOP gate is parsed, it is split into two circuit's gates:
    ///< one will be handled as INPUT gate and the other one as OUTPUT gate.

    std::set<label_t> outputs;

    std::set<size_t> output_circuits;        ///< Set containing the unique ID of all OUTPUT gates
    std::set<size_t> input_circuits;        ///< Set containing the unique ID of all INPUT gates

    std::unordered_map<label_t, bench_node_t> label_to_node;                   ///< Mapping from bench node labels to bench node
    std::unordered_map<label_t, size_t> labels_to_id;                   ///< Mapping from bench node labels to circuit unique IDs
    boost::unordered_map<size_t, circuit_node_t> id_to_circuit_node;  ///< Mapping from circuit unique IDs to circuit nodes

    /* Topological Sorted Circuit */
    list_of_circuit_t sorted_circuit; ///< List contained the topological sorted circuit nodes



    /**
     * \brief Print the labels2node_table table.
     * \param none
     * \return none
     *
     *  It prints all the labels and the data associated to bench nodes.
     */
    void PrintLabelsTable();

    /**
     * \brief Print the uuid2circuitNode_table table.
     * \param none
     * \return none
     *
     *  It prints all the unique IDs and the data associated to circuit nodes.
     */
    void PrintUUIDCircuitTable();

    /**
     * \brief Print the set_of_output_labels list.
     * \param none
     * \return none
     *
     * It prints the list containing the label of all output nodes.
     */
    void PrintOutputList();

    /**
     * \brief Print the labels2uuid_table table.
     * \param none
     * \return none
     *
     *  It prints all the labels and its associates unique circuit ID.
     */
    void PrintLabels2UUIDTable();

    /**
     * \brief prints the circuit starting from the given unique identificator.
     * \param circuit_ID is unique_ID_t corresponding to a node circuit.
     * \param indent is int and represents the depth of the node in the circuit.
     * \return none
     *
     * It prints the circuit starting from circuit_ID node. Indent is an integer
     *      corresponding to the depth of the node in the circuit. Each unity
     *      will add four spaces as identation before printing the node's data.
     *
     */
    void PrintCircuit(unique_ID_t circuit_ID, int indent);

    /**
     * \brief prints the circuit starting from the given label's node.
     * \param node_label is label_t
     * \return none
     *
     */
    void PrintCircuitByLabel(const label_t& node_label);

    /**
     * \brief prints all circuits from the set of circuit OUTPUTS.
     * \param none
     * \return none
     *
     */
    void PrintCircuitsOfOutputSet();

    /**
     * \brief prints the list of topological sorted circuit's node.
     * \param none
     * \return none
     *
     */
    void PrintSortedCircuitList();

    /* ----------------
     * Get functions
     * ----------------
     */

    /**
     * \brief return a list with the UUID of the INPUT gates of the circuit.
     * \param none
     * \return set_of_circuit_t
     *
     */
    set_of_circuit_t GetListOfCircuitsInputs();

    /**
     * \brief return a list with the UUID of the OUTPUT gates of the circuit.
     * \param none
     * \return set_of_circuit_t
     *
     */
    set_of_circuit_t GetListOfCircuitsOutputs();

    /**
     * \brief return a circuit node, given a its unique ID.
     * \param circuit_node_uuid is unique_ID_t
     * \return circuit_node_type
     *
     */
    circuit_node_t GetCircuitNode(unique_ID_t circuit_node_uuid);

    /**
     * \brief return the table representing the circuit.
     * \param none
     * \return boost::unordered_map<unique_ID_t, circuit_node_type>
     *
     */
    boost::unordered_map<unique_ID_t, circuit_node_t> GetCircuit();
    /* ---------------
     * Read File Functions
     * ---------------
     */
    /**
     * \brief Reads the file containing the circuit in the bench format.
     * \param bench_file is std::string.
     * \return bool returns true in case of success.
     *
     *  Reads the file containing the circuit in the bench format.
     */
    bool parseFile(const std::string& bench_file);

    /* ----------------
     * Insert functions
     * ----------------
     */

    /**
     * \brief return the list of circuit nodes topologically sorted.
     * \param bench_node is bench_node_t
     * \return bool:
     *          true  -> Node successfully added
     *          false -> Node already exist and could not be added
     *
     * Adds a node to the labels table (labels2node) and to the
     *      sets_of_outputs in case it is of gate type OUTPUT.
     *
     */
    bool addToLabelTable(bench_node_t bench_node);

    /**
     * \brief search or add the node to the circuit.
     * \param bench_node is bench_node_t
     * \return unique_ID_t representing the given bench_node
     *
     *  It searches if the bench node exist in the label2uuid_table.
     *  If it does't, adds it to the table and return the unique ID.
     *  Otherwise, simply return the unique ID of the node.
     *
     */
    unique_ID_t findOrAddToCircuit(const bench_node_t& bench_node);

    /**
     * \brief find or add a node to the circuit given its label.
     * \param node_label is label_t
     * \return unique_ID_t representing the given label
     *
     *  It searches if the node corresponding to the given label is
     *      already inserted into the labels2uuid_table table. If it is,
     *      returns its id. If not, creates a new node into the circuit
     *      and add it to the table.
     *
     */
    unique_ID_t findOrAddToCircuitByLabel(const label_t& node_label);

    /* --------------------
     * Conversion functions
     * --------------------
     */

    /**
     * \brief converts bench node to circuit node.
     * \param bench_node is bench_node_t and represents the node to be converted.
     * \return circuit_node_type
     *
     *  Given a bench_node_t, it converts the node into an circuit_node_type.
     */
    circuit_node_t benchNodeToCircuitNode(const bench_node_t& bench_node);

    /*
     *
     * Create circuit functions
     *
     */

    /**
     * \brief create a circuit from the labels in the set_of_output_labels.
     * \param none
     * \return none
     *
     */
    void createCircuitFromOutputList();

    /**
     * \brief create a circuit from the given node's label.
     * \param bnode_label is label_t
     * \return none
     *
     */
    void createCircuitByLabel(const label_t& bnode_label);

    /* -----------------------------
     * Topological Sort Algorithms
     * -----------------------------
     */

    /**
     * \brief Implementation of Kahn's Algorithm for topological sort.
     * \param none
     * \return none (the result is stored at sorted_circuit variable)
     *
     */
    void TopologicalSortKahnsAlgorithm();

    /* -----------------------------
     * Auxiliar functions for
     * Topological Sort Algorithms
     * -----------------------------
     */

    /**
     * \brief auxiliar function for topological sort algorithms.
     * \param src_node is unique_ID_t
     * \param dst_node is unique_ID_t
     * \return True if it was the only outgoing edge. False, otherwise.
     *
     * It removes the edge from src->dst at the table uuid2circuitNode and
     * then checks if it was the only outgoing edge.
     */
    bool IsUniqueOutgoingEdge(unique_ID_t src_node, unique_ID_t dst_node);

public:
    /**
    * \brief Constructor
    * \param bench_file the path to the benchmark file
    *
    * Constructor method for the bench_circuit_manager class. It
    * generates the topological circuit described in the file
    * bench_file that must be in the ISCAS85/ISCAS89/ISCAS99 format.
    */
    explicit BenchParser(const std::string& bench_file);

    ~BenchParser();



    /**
     * \brief return the list of circuit nodes topologically sorted.
     * \param none
     * \return list_of_circuit_t
     *
     */
    list_of_circuit_t GetSortedCircuit();

    /**
     * \brief return a list with the labels of the OUTPUT gates of the circuit. The label's list also includes the FLIP_FLOPS
     * \param none
     * \return std::set<label_t>
     *
     */
    std::set<label_t> GetListOfOutputLabels();

};
